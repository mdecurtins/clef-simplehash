package clefdemo.simplehash;

import java.util.List;

import clefdemo.simplehash.db.Database;
import clefdemo.simplehash.humdrum.Filters;
import clefdemo.simplehash.humdrum.KernHasher;
import clefdemo.simplehash.humdrum.KernSpine;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.LinkedList;

/**
 * The main algorithm class. Contains methods for handling MusicXML query input, searching the Simplehash 
 * database, and collecting errors.
 * 
 * @author Max DeCurtins
 * @since 1.0.0
 */
public class Simplehash {

	private List<String> errs;
	
	public Simplehash() {
		this.errs = new LinkedList<String>();
	}
	
	
	/**
	 * Gets any errors generated by this instance of Simplehash.
	 * 
	 * @since 1.0.0
	 * @return a list of error strings
	 */
	public List<String> getErrors() {
		return errs;
	}
	
	
	/**
	 * Determines whether any errors were generated by this instance of Simplehash.
	 * 
	 * @since 1.0.0
	 * @return
	 */
	public boolean hasErrors() {
		return ! this.errs.isEmpty();
	}
	
	
	/**
	 * Performs a hash-based lookup on the database.
	 * 
	 * @since 1.0.0
	 * @param ks a KernSpine containing the symbolic music data to be hashed and searched for.
	 * @return a list of Result objects, empty if no rows returned from the database.
	 */
	public List<Result> lookup( KernSpine ks ) {
		
		List<Result> results = new LinkedList<Result>();
		
		if ( ks.numTokens() == 0 ) {
			this.errs.add( "Error obtaining music data from submitted data." );
			return results;
		}
		
		KernHasher kh = new KernHasher();
		
		// Apply the same filters as were used in processing source data and remove any trailing rests.
		List<String> queryTokens = Filters.trim( ks.applyFilters() );
		
		// Hash the resulting tokens.
		int hash = kh.hash( queryTokens );
		
		// Log the query to the container logs
		System.out.println( "Submitting query: " + kh.printTokensAndHash( queryTokens, hash ) );
		
		try {
			Database db = new Database();
			results = db.selectAllWithHash( hash );
		} catch ( Exception e ) {
			this.errs.add( e.getMessage() );
		}
		
		return results;
	}
	
	
	/**
	 * Gets the number of distinct filenames in the database. This is the number of items that simplehash will search.
	 * 
	 * @since 1.0.0
	 * @return the number of distinct filenames in the database
	 */
	public int numItems() {
		int items = 0;
		try {
			Database db = new Database();
			items = db.numDistinctFiles();
		} catch ( Exception e ) {
			this.errs.add( e.getMessage() );
		}
		
		return items;
	}
	
	
	/**
     * Writes a MusicXML query to a local temp file.
     * 
     * This method will overwrite any existing data in the temp file.
     * 
     * @since 1.0.0
     * @param q symbolic music data in MusicXML format
     */
    public void writeQueryToTempFile( String q ) {
    	// Write MusicXML query to a temp file.
    	Path tmpfile = Paths.get( "/usr/local/tmp/q.xml" );
    	try {
    		Files.write( tmpfile, q.getBytes() );
    	} catch ( IOException ioe ) {
    		this.errs.add( ioe.getMessage() );
    	}
    }
    
	
	/**
     * Converts a MusicXML file to Humdrum.
     * 
     * N.B. This method depends upon the existence of the xml2hum command in the PWD of the simplehash application. This command 
     * can take an option, -sN, where N represents the index of a staff of music to convert from MusicXML to Humdrum. 
     *
     * @since 1.0.0
     * @see http://extras.humdrum.org/man/xml2hum/
     * @param staffIdx the index (1-based) of the MusicXML staff to convert to Humdrum
     * @return a KernSpine representing the MusicXML data
     */
    public KernSpine xml2hum( int staffIdx ) {
    	
    	KernSpine ks = new KernSpine();
    	
    	Runtime rt = Runtime.getRuntime();
    	
    	// Only extract the staff at the specified index.
    	String staffOpt = String.format( "-s%d", staffIdx );
    	String[] cmd = { "./xml2hum", staffOpt, "/usr/local/tmp/q.xml" };
    	
    
    	try {
    		// Execute the command.
    		Process p = rt.exec( cmd );
    		
    		// Read from stdout produced by the command.
    		BufferedReader in = new BufferedReader( new InputStreamReader( p.getInputStream() ) );
    		String line = null;
    		while ( ( line = in.readLine() ) != null ) {
    			
    			// Only include the current line if it is a music token.
    			if ( ! Filters.isInterpretation( line, 1 ) &&
    				 ! Filters.isInstrumentClass( line ) &&
    				 ! Filters.isMeasureDelimiter( line ) ) {
    				System.out.println( "Adding token: " + line );
    				ks.addToken( line );
    			}
    		}
    		
    		// Close the BufferedReader.
    		in.close();
    		
    		// Read any output written by the command to stderr.
    		BufferedReader err = new BufferedReader( new InputStreamReader( p.getErrorStream() ) );
    		StringBuilder sb = new StringBuilder();
    		String e = null;
    		while ( ( e = err.readLine() ) != null ) {
    			// Not sure where this is coming from, but something in xml2hum always prints "GOT HERE" to stderr.
    			// Not part of the xml2hum C++ source, so likely coming from a dependency. Ignore it.
    			if ( ! e.contains( "GOT HERE" ) ) {
    				sb.append( e );
    			}
    		}
    		
    		if ( sb.length() != 0 ) {
    			this.errs.add( sb.toString() );
    		}
    		
    		// Close the BufferedReader.
    		err.close();
    	} catch ( IOException ioe ) {
    		this.errs.add( ioe.getMessage() );
    	}
    	
    	return ks;
    }
}
